<p>
Python 逐渐成了干活的主力，所以最近一直在看书和材料精进一下 Python 的技艺。这里
记录一下读书中觉得受用的知识点，以供之后复习。
</p>

<!--TEASER_END-->

<div id="outline-container-orga76a5b2" class="outline-2">
<h2 id="orga76a5b2">1. 生成器表达式</h2>
<div class="outline-text-2" id="text-orga76a5b2">
<p>
主要的用法如下，可以使用一个括号快速生成一个 generator，惰性地生成内容，主要优点是较 for list comprehension 内存节省很多。
</p>

<div class="highlight"><pre><span></span><span class="n">it</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/tmp/my_file.txt&#39;</span><span class="p">))</span>
<span class="n">next_item</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
<span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></div>

<p>
Python 中的 Generator 并没有常见的 has<sub>next</sub> 方法，而是通过处理 next 抛出的 StopException 来表明已经到了终点, 这是 Python 语言的哲学，  EAFP (easier to
ask for forgiveness than permission), has<sub>next</sub> 遵循的原则是 LBYL (look before you leap)，与 EAFP 相悖。其实也是，我自己在做 SimpleDB 的时候，要支持 hasNext 方法，往往都需要在上一次的 next 方法中提前算好下一次的，效率上确实有所牺牲，但是拿一个 Exception 来做 Flow control 确实不大好。
</p>
</div>
</div>

<div id="outline-container-org93d4794" class="outline-2">
<h2 id="org93d4794">2. 尽量使用 enumerate 取代 range</h2>
<div class="outline-text-2" id="text-org93d4794">
<p>
使用内置的 enumerate 可以同时拿到 index 和 item。
</p>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">flavor</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">flavor_list</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">flavor</span><span class="p">))</span>
</pre></div>
</div>
</div>

<div id="outline-container-org026dd1a" class="outline-2">
<h2 id="org026dd1a">3. Python 的迭代器协议</h2>
<div class="outline-text-2" id="text-org026dd1a">
<p>
Python 的 for 语句，以及一些接受 iterator 的函数，都会先调用对象的_<sub>iter</sub>_<sub>方法</sub>，得到
一个迭代器对象，之后再反复调用 next 方法，直至耗尽并产生 StopIteration 异常。
根据这个特点，我们可以在类中 override _<sub>iter</sub>_<sub>方法</sub>，并返回一个新的 generator 对象，
保证这个实例能够重复被迭代。
</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ReadVisits</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_path</span><span class="p">):</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">data_path</span> <span class="o">=</span> <span class="n">data_path</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
	    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
		<span class="k">yield</span> <span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</pre></div>
</div>
</div>

<div id="outline-container-org7ca93b1" class="outline-2">
<h2 id="org7ca93b1">4. 参数的默认值</h2>
<div class="outline-text-2" id="text-org7ca93b1">
<p>
参数的默认值只在执行定义函数的时候定义一次，所以当这个值是一个可变参数时，往往会
出错。比如:
</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">when</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">when</span><span class="p">,</span> <span class="n">message</span><span class="p">))</span>
<span class="n">log</span><span class="p">(</span><span class="s2">&quot;hi&quot;</span><span class="p">)</span>
<span class="n">log</span><span class="p">(</span><span class="s2">&quot;there&quot;</span><span class="p">)</span>
</pre></div>
<p>
两次调用的 when 将会是一致的，这显然不是我们想要的，作者建议我们使用 None 来表示缺省
值。
</p>

<p>
另外还会有一种情况，如:
</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">decode</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">{}):</span>
    <span class="k">try</span><span class="p">:</span>
	<span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
	<span class="k">return</span> <span class="n">default</span>
</pre></div>

<p>
每次调用 decode 方法返回的 default 其实是同一个对象。
</p>
</div>
</div>
<div id="outline-container-orgfd23708" class="outline-2">
<h2 id="orgfd23708">5. 强制使用关键字参数</h2>
<div class="outline-text-2" id="text-orgfd23708">
<p>
有时我们希望用户只能使用关键字参数，不能使用位置参数，这个需求可以用*来占位实现，
如下：
</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">safe_division</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="n">divisor</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">ignore_overflow</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
</div>
<div id="outline-container-orgc745f9f" class="outline-2">
<h2 id="orgc745f9f">6. 多用 public 属性，少用 private 属性</h2>
<div class="outline-text-2" id="text-orgc745f9f">
<p>
Python 编译器无法严格保证 private 字段的私密性，所以最大的优势没了，而且在继承的子
类中，也是无法访问父类的属性，这样反而会带来更多的麻烦，应该多用 protected 属性。
</p>
</div>
</div>
<div id="outline-container-org6a555ee" class="outline-2">
<h2 id="org6a555ee">7. 继承 collections.abi 以实现自定义的容器类型</h2>
<div class="outline-text-2" id="text-org6a555ee">
<p>
collections.abi 包中定义了一系列的容器抽象类，其中定义了一系列的必须实现的基本方
法，继承类实现这些方法，就可以将这个继承类当成对应的容器类使用了。
</p>
</div>
</div>
